Index: frameworks/base/core/java/android/view/ViewRootImpl.java
===================================================================
--- frameworks/base/core/java/android/view/ViewRootImpl.java	(revision 1831)
+++ frameworks/base/core/java/android/view/ViewRootImpl.java	(working copy)
@@ -756,6 +756,7 @@
 
     void setLayoutParams(WindowManager.LayoutParams attrs, boolean newView) {
         synchronized (this) {
+            Trace.traceBegin(Trace.TRACE_TAG_VIEW, "setLayoutParams");
             int oldSoftInputMode = mWindowAttributes.softInputMode;
             // Keep track of the actual window flags supplied by the client.
             mClientWindowLayoutFlags = attrs.flags;
@@ -784,24 +785,30 @@
             }
             mWindowAttributesChanged = true;
             scheduleTraversals();
+            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
         }
     }
 
     void handleAppVisibility(boolean visible) {
         if (mAppVisible != visible) {
+            Trace.traceBegin(Trace.TRACE_TAG_VIEW, "handleAppVisibility");
             mAppVisible = visible;
             scheduleTraversals();
+            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
         }
     }
 
     void handleGetNewSurface() {
+        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "handleGetNewSurface");
         mNewSurfaceNeeded = true;
         mFullRedrawNeeded = true;
         scheduleTraversals();
+        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
     }
 
     void handleScreenStateChange(boolean on) {
         if (on != mAttachInfo.mScreenOn) {
+            Trace.traceBegin(Trace.TRACE_TAG_VIEW, "handleScreenStateChange");
             mAttachInfo.mScreenOn = on;
             if (mView != null) {
                 mView.dispatchScreenStateChanged(on ? View.SCREEN_STATE_ON : View.SCREEN_STATE_OFF);
@@ -810,21 +817,26 @@
                 mFullRedrawNeeded = true;
                 scheduleTraversals();
             }
+            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
         }
     }
 
     @Override
     public void requestFitSystemWindows() {
+        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "requestFitSystemWindows");
         checkThread();
         mFitSystemWindowsRequested = true;
         scheduleTraversals();
+        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
     }
 
     @Override
     public void requestLayout() {
+        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "requestLayout");
         checkThread();
         mLayoutRequested = true;
         scheduleTraversals();
+        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
     }
 
     @Override
@@ -833,8 +845,10 @@
     }
 
     void invalidate() {
+        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "invalidate");
         mDirty.set(0, 0, mWidth, mHeight);
         scheduleTraversals();
+        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
     }
 
     void invalidateWorld(View view) {
@@ -894,7 +908,9 @@
             localDirty.setEmpty();
         }
         if (!mWillDrawSoon && (intersected || mIsAnimating)) {
+            Trace.traceBegin(Trace.TRACE_TAG_VIEW, "invalidateChildInParent");
             scheduleTraversals();
+            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
         }
 
         return null;
@@ -904,7 +920,9 @@
         if (mStopped != stopped) {
             mStopped = stopped;
             if (!stopped) {
+                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "setStopped");
                 scheduleTraversals();
+                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
             }
         }
     }
@@ -960,20 +978,24 @@
 
     void scheduleTraversals() {
         if (!mTraversalScheduled) {
+            Trace.traceBegin(Trace.TRACE_TAG_VIEW, "scheduleTraversals");
             mTraversalScheduled = true;
             mTraversalBarrier = mHandler.getLooper().postSyncBarrier();
             mChoreographer.postCallback(
                     Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
             scheduleConsumeBatchedInput();
+            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
         }
     }
 
     void unscheduleTraversals() {
         if (mTraversalScheduled) {
+            Trace.traceBegin(Trace.TRACE_TAG_VIEW, "unscheduleTraversals");
             mTraversalScheduled = false;
             mHandler.getLooper().removeSyncBarrier(mTraversalBarrier);
             mChoreographer.removeCallbacks(
                     Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
+            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
         }
     }
 
@@ -1881,7 +1903,7 @@
     }
 
     private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {
-        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "measure");
+        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "performMeasure");
         try {
             mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
             mInputWindowOffset = computeInputWindowOffset();
@@ -1900,7 +1922,7 @@
                     host.getMeasuredWidth() + ", " + host.getMeasuredHeight() + ")");
         }
 
-        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "layout");
+        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "performLayout");
         try {
             host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());
             mInputWindowOffset = computeInputWindowOffset();
@@ -2058,7 +2080,7 @@
         mFullRedrawNeeded = false;
 
         mIsDrawing = true;
-        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "draw");
+        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "performDraw");
         try {
             draw(fullRedrawNeeded);
         } finally {
@@ -2383,6 +2405,7 @@
     }
 
     void invalidateDisplayLists() {
+        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "invalidateDisplayList");
         final ArrayList<DisplayList> displayLists = mDisplayLists;
         final int count = displayLists.size();
 
@@ -2393,6 +2416,7 @@
         }
 
         displayLists.clear();
+        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
     }
 
     boolean scrollToRectOrFocus(Rect rectangle, boolean immediate) {
Index: frameworks/base/core/java/android/app/LocalActivityManager.java
===================================================================
--- frameworks/base/core/java/android/app/LocalActivityManager.java	(revision 1831)
+++ frameworks/base/core/java/android/app/LocalActivityManager.java	(working copy)
@@ -21,6 +21,7 @@
 import android.os.Binder;
 import android.os.Bundle;
 import android.util.Log;
+import android.os.Trace;
 import android.view.Window;
 
 import java.util.ArrayList;
@@ -108,8 +109,10 @@
     }
 
     private void moveToState(LocalActivityRecord r, int desiredState) {
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "moveToState");
         if (r.curState == RESTORED || r.curState == DESTROYED) {
             // startActivity() has not yet been called, so nothing to do.
+            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
             return;
         }
         
@@ -135,6 +138,7 @@
             r.activity = mActivityThread.startActivityNow(
                     mParent, r.id, r.intent, r.activityInfo, r, r.instanceState, instance);
             if (r.activity == null) {
+                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                 return;
             }
             r.window = r.activity.getWindow();
@@ -153,6 +157,7 @@
             // of our own (it is now STARTED, while we are only CREATED).
             // If we just leave things as-is, we'll deal with it as the
             // group's state catches up.
+            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
             return;
         }
         
@@ -169,6 +174,7 @@
                     mActivityThread.performResumeActivity(r, true);
                     r.curState = RESUMED;
                 }
+                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                 return;
                 
             case STARTED:
@@ -184,6 +190,7 @@
                     mActivityThread.performStopActivity(r, false);
                     r.curState = CREATED;
                 }
+                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                 return;
                 
             case RESUMED:
@@ -199,6 +206,7 @@
                     mActivityThread.performStopActivity(r, false);
                     r.curState = CREATED;
                 }
+                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                 return;
         }
     }
Index: frameworks/base/core/java/android/app/Fragment.java
===================================================================
--- frameworks/base/core/java/android/app/Fragment.java	(revision 1831)
+++ frameworks/base/core/java/android/app/Fragment.java	(working copy)
@@ -25,6 +25,7 @@
 import android.os.Bundle;
 import android.os.Parcel;
 import android.os.Parcelable;
+import android.os.Trace;
 import android.util.AndroidRuntimeException;
 import android.util.AttributeSet;
 import android.util.DebugUtils;
@@ -1666,6 +1667,7 @@
     }
 
     void performCreate(Bundle savedInstanceState) {
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Frag-performCreate");
         if (mChildFragmentManager != null) {
             mChildFragmentManager.noteStateNotSaved();
         }
@@ -1685,6 +1687,7 @@
                 mChildFragmentManager.dispatchCreate();
             }
         }
+        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
     }
 
     View performCreateView(LayoutInflater inflater, ViewGroup container,
@@ -1711,6 +1714,7 @@
     }
 
     void performStart() {
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Frag-performStart");
         if (mChildFragmentManager != null) {
             mChildFragmentManager.noteStateNotSaved();
             mChildFragmentManager.execPendingActions();
@@ -1727,6 +1731,7 @@
         if (mLoaderManager != null) {
             mLoaderManager.doReportStart();
         }
+    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
     }
 
     void performResume() {
Index: frameworks/base/core/java/android/app/ActivityThread.java
===================================================================
--- frameworks/base/core/java/android/app/ActivityThread.java	(revision 1831)
+++ frameworks/base/core/java/android/app/ActivityThread.java	(working copy)
@@ -2086,7 +2086,7 @@
 
     private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
         // System.out.println("##### [" + System.currentTimeMillis() + "] ActivityThread.performLaunchActivity(" + r + ")");
-
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "performLaunchActivity");
         ActivityInfo aInfo = r.activityInfo;
         if (r.packageInfo == null) {
             r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,
@@ -2196,12 +2196,13 @@
                     + ": " + e.toString(), e);
             }
         }
-
+        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
         return activity;
     }
 
     private Context createBaseContextForActivity(ActivityClientRecord r,
             final Activity activity) {
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "createBaseContextForActivity");
         ContextImpl appContext = new ContextImpl();
         appContext.init(r.packageInfo, r.token, this);
         appContext.setOuterContext(activity);
@@ -2222,12 +2223,14 @@
                 }
             }
         }
+        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
         return baseContext;
     }
 
     private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {
         // If we are getting ready to gc after going to the background, well
         // we are back active so skip it.
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "handleLaunchActivity");
         unscheduleGcIdler();
 
         if (r.profileFd != null) {
@@ -2301,6 +2304,7 @@
                 // Ignore
             }
         }
+        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
     }
 
     private void deliverNewIntents(ActivityClientRecord r,
@@ -2514,6 +2518,7 @@
     private void handleCreateService(CreateServiceData data) {
         // If we are getting ready to gc after going to the background, well
         // we are back active so skip it.
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "handleCreateService");
         unscheduleGcIdler();
 
         LoadedApk packageInfo = getPackageInfoNoCheck(
@@ -2555,9 +2560,11 @@
                     + ": " + e.toString(), e);
             }
         }
+    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
     }
 
     private void handleBindService(BindServiceData data) {
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "handleBindService");
         Service s = mServices.get(data.token);
         if (DEBUG_SERVICE)
             Slog.v(TAG, "handleBindService s=" + s + " rebind=" + data.rebind);
@@ -2585,6 +2592,7 @@
                 }
             }
         }
+        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
     }
 
     private void handleUnbindService(BindServiceData data) {
@@ -2725,6 +2733,7 @@
 
     public final ActivityClientRecord performResumeActivity(IBinder token,
             boolean clearHide) {
+         Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "performResumeActivity");
         ActivityClientRecord r = mActivities.get(token);
         if (localLOGV) Slog.v(TAG, "Performing resume of " + r
                 + " finished=" + r.activity.mFinished);
@@ -2760,6 +2769,7 @@
                 }
             }
         }
+        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
         return r;
     }
 
@@ -2780,6 +2790,7 @@
             boolean reallyResume) {
         // If we are getting ready to gc after going to the background, well
         // we are back active so skip it.
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "handleResumeActivity");
         unscheduleGcIdler();
 
         ActivityClientRecord r = performResumeActivity(token, clearHide);
@@ -2900,6 +2911,7 @@
             } catch (RemoteException ex) {
             }
         }
+    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
     }
 
     private int mThumbnailWidth = -1;
@@ -3957,7 +3969,7 @@
     }
 
     final void handleConfigurationChanged(Configuration config, CompatibilityInfo compat) {
-
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "handleConfigurationChanged");
         int configDiff = 0;
 
         synchronized (mPackages) {
@@ -3971,6 +3983,7 @@
             }
 
             if (config == null) {
+                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                 return;
             }
             
@@ -3983,6 +3996,7 @@
                 mConfiguration = new Configuration();
             }
             if (!mConfiguration.isOtherSeqNewer(config) && compat == null) {
+                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                 return;
             }
             configDiff = mConfiguration.diff(config);
@@ -4003,6 +4017,7 @@
                 performConfigurationChanged(callbacks.get(i), config);
             }
         }
+        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
     }
 
     final void freeTextLayoutCachesIfNeeded(int configDiff) {
@@ -4175,6 +4190,7 @@
     }
 
     private void handleBindApplication(AppBindData data) {
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "handleBindApplication");
         mBoundApplication = data;
         mConfiguration = new Configuration(data.config);
         mCompatConfiguration = new Configuration(data.config);
@@ -4429,6 +4445,7 @@
         } finally {
             StrictMode.setThreadPolicy(savedPolicy);
         }
+        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
     }
 
     /*package*/ final void finishInstrumentation(int resultCode, Bundle results) {
Index: frameworks/base/core/java/android/app/LoadedApk.java
===================================================================
--- frameworks/base/core/java/android/app/LoadedApk.java	(revision 1831)
+++ frameworks/base/core/java/android/app/LoadedApk.java	(working copy)
@@ -487,7 +487,9 @@
 
     public Application makeApplication(boolean forceDefaultAppClass,
             Instrumentation instrumentation) {
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "makeApplication");
         if (mApplication != null) {
+            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
             return mApplication;
         }
 
@@ -526,7 +528,7 @@
                 }
             }
         }
-        
+        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
         return app;
     }
 
Index: frameworks/base/core/java/android/app/Activity.java
===================================================================
--- frameworks/base/core/java/android/app/Activity.java	(revision 1831)
+++ frameworks/base/core/java/android/app/Activity.java	(working copy)
@@ -50,6 +50,7 @@
 import android.os.RemoteException;
 import android.os.StrictMode;
 import android.os.UserHandle;
+import android.os.Trace;
 import android.text.Selection;
 import android.text.SpannableStringBuilder;
 import android.text.TextUtils;
@@ -5150,13 +5151,17 @@
     }
 
     final void performCreate(Bundle icicle) {
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Activity-performCreate");
         onCreate(icicle);
+
         mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(
                 com.android.internal.R.styleable.Window_windowNoDisplay, false);
         mFragments.dispatchActivityCreated();
+        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
     }
     
     final void performStart() {
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Activity-performStart");
         mFragments.noteStateNotSaved();
         mCalled = false;
         mFragments.execPendingActions();
@@ -5178,6 +5183,7 @@
                 }
             }
         }
+    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
     }
     
     final void performRestart() {
Index: frameworks/base/core/java/android/app/Instrumentation.java
===================================================================
--- frameworks/base/core/java/android/app/Instrumentation.java	(revision 1831)
+++ frameworks/base/core/java/android/app/Instrumentation.java	(working copy)
@@ -34,6 +34,7 @@
 import android.os.ServiceManager;
 import android.os.SystemClock;
 import android.os.UserHandle;
+import android.os.Trace;
 import android.util.AndroidRuntimeException;
 import android.util.Log;
 import android.view.IWindowManager;
@@ -997,7 +998,9 @@
      * @param app The application being created.
      */
     public void callApplicationOnCreate(Application app) {
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "app->onCreate()");
         app.onCreate();
+        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
     }
     
     /**
@@ -1051,7 +1054,11 @@
             Intent intent)
             throws InstantiationException, IllegalAccessException,
             ClassNotFoundException {
-        return (Activity)cl.loadClass(className).newInstance();
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "newActivity");
+        Activity returnValue = (Activity)cl.loadClass(className).newInstance();
+        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
+        return returnValue;
+//        return (Activity)cl.loadClass(className).newInstance();
     }
 
     /**
@@ -1063,6 +1070,7 @@
      *               onCreate().
      */
     public void callActivityOnCreate(Activity activity, Bundle icicle) {
+        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "callActivityOnCreate");
         if (mWaitingActivities != null) {
             synchronized (mSync) {
                 final int N = mWaitingActivities.size();
@@ -1088,6 +1096,7 @@
                 }
             }
         }
+    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
     }
     
     public void callActivityOnDestroy(Activity activity) {
Index: frameworks/base/core/java/android/app/Application.java
===================================================================
--- frameworks/base/core/java/android/app/Application.java	(revision 1831)
+++ frameworks/base/core/java/android/app/Application.java	(working copy)
@@ -24,6 +24,7 @@
 import android.content.ContextWrapper;
 import android.content.res.Configuration;
 import android.os.Bundle;
+import android.os.Trace;
 
 /**
  * Base class for those who need to maintain global application state. You can
@@ -152,8 +153,10 @@
         Object[] callbacks = collectActivityLifecycleCallbacks();
         if (callbacks != null) {
             for (int i=0; i<callbacks.length; i++) {
+                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "dispatchActivityCreated");
                 ((ActivityLifecycleCallbacks)callbacks[i]).onActivityCreated(activity,
                         savedInstanceState);
+                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
             }
         }
     }
@@ -162,7 +165,9 @@
         Object[] callbacks = collectActivityLifecycleCallbacks();
         if (callbacks != null) {
             for (int i=0; i<callbacks.length; i++) {
+                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "dispatchActivityStarted");
                 ((ActivityLifecycleCallbacks)callbacks[i]).onActivityStarted(activity);
+                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
             }
         }
     }
@@ -171,7 +176,9 @@
         Object[] callbacks = collectActivityLifecycleCallbacks();
         if (callbacks != null) {
             for (int i=0; i<callbacks.length; i++) {
+                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "dispatchActivityResumed");
                 ((ActivityLifecycleCallbacks)callbacks[i]).onActivityResumed(activity);
+                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
             }
         }
     }
Index: frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/BatteryController.java
===================================================================
--- frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/BatteryController.java	(revision 1831)
+++ frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/BatteryController.java	(working copy)
@@ -157,7 +157,7 @@
 
 		mAnimationLevel = mAnimationLevel + 1;// charging step is 1%
 
-		mView.setImageLevel(mAnimationLevel * 100);
+		//mView.setImageLevel(mAnimationLevel * 100);
 
 		/*
 		 * 动画到满的时候，顿800ms，然后重新开始动画
Index: frameworks/base/libs/hwui/DisplayListRenderer.cpp
===================================================================
--- frameworks/base/libs/hwui/DisplayListRenderer.cpp	(revision 1831)
+++ frameworks/base/libs/hwui/DisplayListRenderer.cpp	(working copy)
@@ -15,10 +15,12 @@
  */
 
 #define LOG_TAG "OpenGLRenderer"
+#define ATRACE_TAG ATRACE_TAG_GRAPHICS
 
 #include <SkCamera.h>
 
 #include <private/hwui/DrawGlInfo.h>
+#include <utils/Trace.h>
 
 #include "DisplayListLogBuffer.h"
 #include "DisplayListRenderer.h"
@@ -193,6 +195,7 @@
 
 void DisplayList::initFromDisplayListRenderer(const DisplayListRenderer& recorder, bool reusing) {
 
+    ATRACE_CALL();
     if (reusing) {
         // re-using display list - clear out previous allocations
         clearResources();
Index: frameworks/native/services/surfaceflinger/EventThread.cpp
===================================================================
--- frameworks/native/services/surfaceflinger/EventThread.cpp	(revision 1831)
+++ frameworks/native/services/surfaceflinger/EventThread.cpp	(working copy)
@@ -149,6 +149,7 @@
     // dispatch events to listeners...
     const size_t count = signalConnections.size();
     for (size_t i=0 ; i<count ; i++) {
+        ATRACE_NAME("Vsync_PostEvent");
         const sp<Connection>& conn(signalConnections[i]);
         // now see if we still need to report this event
         status_t err = conn->postEvent(event);
@@ -185,6 +186,9 @@
         size_t vsyncCount = 0;
         nsecs_t timestamp = 0;
         for (int32_t i=0 ; i<HWC_DISPLAY_TYPES_SUPPORTED ; i++) {
+            char buf[30];
+            sprintf(buf, "Vsync_deliver %d", mVSyncEvent[i].header.timestamp);
+            ATRACE_NAME(buf);
             timestamp = mVSyncEvent[i].header.timestamp;
             if (timestamp) {
                 // we have a vsync event to dispatch
@@ -208,6 +212,7 @@
         // find out connections waiting for events
         size_t count = mDisplayEventConnections.size();
         for (size_t i=0 ; i<count ; i++) {
+            ATRACE_NAME("Vsync_Event_handle");
             sp<Connection> connection(mDisplayEventConnections[i].promote());
             if (connection != NULL) {
                 bool added = false;
Index: frameworks/native/services/surfaceflinger/Layer.cpp
===================================================================
--- frameworks/native/services/surfaceflinger/Layer.cpp	(revision 1831)
+++ frameworks/native/services/surfaceflinger/Layer.cpp	(working copy)
@@ -309,7 +309,7 @@
 
 void Layer::onDraw(const sp<const DisplayDevice>& hw, const Region& clip) const
 {
-    ATRACE_CALL();
+    ATRACE_NAME("Layer->onDraw");
 
     if (CC_UNLIKELY(mActiveBuffer == 0)) {
         // the texture has not been created yet, this Layer has

@@ -546,6 +547,7 @@
         // compositionComplete() call.
         // we'll trigger an update in onPreComposition().
         if (mRefreshPending) {
+            ATRACE_NAME("mRefreshPending true");
             return outDirtyRegion;
         }
 
Index: frameworks/native/services/surfaceflinger/DisplayDevice.cpp
===================================================================
--- frameworks/native/services/surfaceflinger/DisplayDevice.cpp	(revision 1831)
+++ frameworks/native/services/surfaceflinger/DisplayDevice.cpp	(working copy)
@@ -13,6 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+#define ATRACE_TAG ATRACE_TAG_GRAPHICS
+#include <utils/Trace.h>
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -208,6 +210,7 @@
 }
 
 void DisplayDevice::swapBuffers(HWComposer& hwc) const {
+    ATRACE_NAME("DispalyDevice->swapBuffers");
     EGLBoolean success = EGL_TRUE;
     if (hwc.initCheck() != NO_ERROR) {
         // no HWC, we call eglSwapBuffers()
Index: frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp
===================================================================
--- frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp	(revision 1831)
+++ frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp	(working copy)
@@ -14,7 +14,7 @@
  ** See the License for the specific language governing permissions and
  ** limitations under the License.
  */
-
+#define ATRACE_TAG ATRACE_TAG_GRAPHICS
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -23,6 +23,7 @@
 #include <cutils/log.h>
 
 #include <utils/String8.h>
+#include <utils/Trace.h>
 
 #include <ui/Rect.h>
 
@@ -57,6 +58,7 @@
     mCurrentBuffer(0),
     mHwc(hwc)
 {
+    ATRACE_NAME("FBS-FramebufferSurface");
     mName = "FramebufferSurface";
     mBufferQueue->setConsumerName(mName);
     mBufferQueue->setConsumerUsageBits(GRALLOC_USAGE_HW_FB |
@@ -72,6 +74,7 @@
 }
 
 status_t FramebufferSurface::nextBuffer(sp<GraphicBuffer>& outBuffer, sp<Fence>& outFence) {
+    ATRACE_NAME("FBS-nextBuffer");
     Mutex::Autolock lock(mMutex);
 
     BufferQueue::BufferItem item;
@@ -111,6 +114,7 @@
 
 // Overrides ConsumerBase::onFrameAvailable(), does not call base class impl.
 void FramebufferSurface::onFrameAvailable() {
+    ATRACE_NAME("FBS-onFrameAvailable");
     sp<GraphicBuffer> buf;
     sp<Fence> acquireFence;
     status_t err = nextBuffer(buf, acquireFence);
@@ -151,7 +155,8 @@
 }
 
 status_t FramebufferSurface::compositionComplete()
-{
+{   
+    ATRACE_NAME("FBS-compositionComplete");
     return mHwc.fbCompositionComplete();
 }
 
Index: frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
===================================================================
--- frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp	(revision 1831)
+++ frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp	(working copy)
@@ -470,7 +470,9 @@
         const int32_t newValue = enabled ? eventBit : 0;
         const int32_t oldValue = mDisplayData[disp].events & eventBit;
         if (newValue != oldValue) {
-            ATRACE_CALL();
+            char buf[25];
+            sprintf(buf, "eventControl %d", enabled);
+            ATRACE_NAME(buf);
             err = mHwc->eventControl(mHwc, disp, event, enabled);
             if (!err) {
                 int32_t& events(mDisplayData[disp].events);
@@ -489,6 +491,7 @@
 }
 
 status_t HWComposer::createWorkList(int32_t id, size_t numLayers) {
+    ATRACE_CALL();
     if (uint32_t(id)>31 || !mAllocatedDisplayIDs.hasBit(id)) {
         return BAD_INDEX;
     }
@@ -591,7 +594,12 @@
         }
     }
 
-    int err = mHwc->prepare(mHwc, mNumDisplays, mLists);
+    int err = NO_ERROR;
+    {
+        ATRACE_NAME("HWC->Prepare");
+        err = mHwc->prepare(mHwc, mNumDisplays, mLists);
+    }
+//    int err = mHwc->prepare(mHwc, mNumDisplays, mLists);
     ALOGE_IF(err, "HWComposer: prepare failed (%s)", strerror(-err));
 
     if (err == NO_ERROR) {
@@ -676,9 +684,11 @@
             ALOGD("commit() waits fbPost() retrycount = %d", retrycount);
         }
 #endif
+        {
+            ATRACE_NAME("HWC->Set");
+            err = mHwc->set(mHwc, mNumDisplays, mLists);
+        }
 
-        err = mHwc->set(mHwc, mNumDisplays, mLists);
-
 #if defined(NO_FENCE_SYNC)
         if (hasGlesComposition(DisplayDevice::DISPLAY_PRIMARY))
             flag_commit_called++;
@@ -752,6 +762,7 @@
 
 int HWComposer::fbPost(int32_t id,
         const sp<Fence>& acquireFence, const sp<GraphicBuffer>& buffer) {
+        ATRACE_CALL();
     if (mHwc && hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) {
 #if defined(NO_FENCE_SYNC)
         int ret = setFramebufferTarget(id, acquireFence, buffer);
Index: frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
===================================================================
--- frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	(revision 1831)
+++ frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	(working copy)
@@ -766,7 +766,7 @@
 }
 
 void SurfaceFlinger::onMessageReceived(int32_t what) {
-    ATRACE_CALL();
+    ATRACE_NAME("SurfaceFlg-onMessageRecerived");
     switch (what) {
     case MessageQueue::INVALIDATE:
         handleMessageTransaction();
@@ -803,6 +803,7 @@
 
 void SurfaceFlinger::doDebugFlashRegions()
 {
+    ATRACE_CALL();
     // is debugging enabled
     if (CC_LIKELY(!mDebugRegion))
         return;
@@ -857,6 +858,7 @@
 
 void SurfaceFlinger::preComposition()
 {
+    ATRACE_CALL();
     bool needExtraInvalidate = false;
     const LayerVector& currentLayers(mDrawingState.layersSortedByZ);
     const size_t count = currentLayers.size();
@@ -972,6 +974,7 @@
 }
 
 void SurfaceFlinger::setUpHWComposer() {
+    ATRACE_CALL();
     HWComposer& hwc(getHwComposer());
     if (hwc.initCheck() == NO_ERROR) {
         // build the h/w work list
@@ -1502,6 +1505,7 @@
 
 void SurfaceFlinger::handlePageFlip()
 {
+    ATRACE_CALL();
     Region dirtyRegion;
 
     bool visibleRegions = false;
@@ -1526,6 +1530,7 @@
 void SurfaceFlinger::doDisplayComposition(const sp<const DisplayDevice>& hw,
         const Region& inDirtyRegion)
 {
+    ATRACE_CALL();
     Region dirtyRegion(inDirtyRegion);
 
     // compute the invalid region
@@ -1562,6 +1567,7 @@
 
 void SurfaceFlinger::doComposeSurfaces(const sp<const DisplayDevice>& hw, const Region& dirty)
 {
+    ATRACE_CALL();
     const int32_t id = hw->getHwcDisplayId();
     HWComposer& hwc(getHwComposer());
     HWComposer::LayerListIterator cur = hwc.begin(id);
Index: frameworks/native/services/surfaceflinger/LayerBase.cpp
===================================================================
--- frameworks/native/services/surfaceflinger/LayerBase.cpp	(revision 1831)
+++ frameworks/native/services/surfaceflinger/LayerBase.cpp	(working copy)
@@ -13,6 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+#define ATRACE_TAG ATRACE_TAG_GRAPHICS
+#include <utils/Trace.h>
 
 #include <stdlib.h>
 #include <stdint.h>
@@ -384,6 +386,7 @@
 
 void LayerBase::drawWithOpenGL(const sp<const DisplayDevice>& hw, const Region& clip) const
 {
+    ATRACE_CALL();
     const uint32_t fbHeight = hw->getHeight();
     const State& s(drawingState());
 
Index: frameworks/native/opengl/libs/EGL/eglApi.cpp
===================================================================
--- frameworks/native/opengl/libs/EGL/eglApi.cpp	(revision 1831)
+++ frameworks/native/opengl/libs/EGL/eglApi.cpp	(working copy)
@@ -874,7 +874,11 @@
         }
     }
 
-    EGLBoolean result = s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
+    EGLBoolean result = 0;
+    {
+        ATRACE_NAME("PVR->eglSwapBuffers");
+        result = s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
+    }
 
     if (CC_UNLIKELY(dp->traceGpuCompletion)) {
         EGLSyncKHR sync = EGL_NO_SYNC_KHR;
Index: frameworks/native/opengl/libs/EGL/egl_display.cpp
===================================================================
--- frameworks/native/opengl/libs/EGL/egl_display.cpp	(revision 1831)
+++ frameworks/native/opengl/libs/EGL/egl_display.cpp	(working copy)
@@ -245,7 +245,7 @@
         finishOnSwap = true;
     }
 
-    property_get("debug.egl.traceGpuCompletion", value, "0");
+    property_get("debug.egl.traceGpuCompletion", value, "1");
     if (atoi(value)) {
         traceGpuCompletion = true;
     }
Index: frameworks/native/libs/gui/ISurfaceComposer.cpp
===================================================================
--- frameworks/native/libs/gui/ISurfaceComposer.cpp	(revision 1831)
+++ frameworks/native/libs/gui/ISurfaceComposer.cpp	(working copy)
@@ -16,6 +16,7 @@
 
 // tag as surfaceflinger
 #define LOG_TAG "SurfaceFlinger"
+#define ATRACE_TAG ATRACE_TAG_GRAPHICS
 
 #include <stdint.h>
 #include <sys/types.h>
@@ -35,6 +36,7 @@
 #include <ui/DisplayInfo.h>
 
 #include <utils/Log.h>
+#include <utils/Trace.h>
 
 // ---------------------------------------------------------------------------
 
@@ -234,16 +236,19 @@
 {
     switch(code) {
         case CREATE_CONNECTION: {
+            ATRACE_NAME("CREATE_CONNECTION");
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             sp<IBinder> b = createConnection()->asBinder();
             reply->writeStrongBinder(b);
         } break;
         case CREATE_GRAPHIC_BUFFER_ALLOC: {
+            ATRACE_NAME("CREATE_GRAPHIC_BUFFER_ALLOC");
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             sp<IBinder> b = createGraphicBufferAlloc()->asBinder();
             reply->writeStrongBinder(b);
         } break;
         case SET_TRANSACTION_STATE: {
+            ATRACE_NAME("SET_TRANSACTION_STATE");
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             size_t count = data.readInt32();
             ComposerState s;
@@ -265,10 +270,12 @@
             setTransactionState(state, displays, flags);
         } break;
         case BOOT_FINISHED: {
+            ATRACE_NAME("BOOT_FINISHED");
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             bootFinished();
         } break;
         case CAPTURE_SCREEN: {
+            ATRACE_NAME("CAPTURE_SCREEN");
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             sp<IBinder> display = data.readStrongBinder();
             uint32_t reqWidth = data.readInt32();
@@ -287,6 +294,7 @@
             reply->writeInt32(res);
         } break;
         case AUTHENTICATE_SURFACE: {
+            ATRACE_NAME("AUTHENTICATE_SURFACE");
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             sp<ISurfaceTexture> surfaceTexture =
                     interface_cast<ISurfaceTexture>(data.readStrongBinder());
@@ -294,12 +302,14 @@
             reply->writeInt32(result);
         } break;
         case CREATE_DISPLAY_EVENT_CONNECTION: {
+            ATRACE_NAME("CREATE_DISPLAY_EVENT_CONNECTION");
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             sp<IDisplayEventConnection> connection(createDisplayEventConnection());
             reply->writeStrongBinder(connection->asBinder());
             return NO_ERROR;
         } break;
         case CREATE_DISPLAY: {
+            ATRACE_NAME("CREATE_DISPLAY");
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             String8 displayName = data.readString8();
             bool secure = bool(data.readInt32());
@@ -308,6 +318,7 @@
             return NO_ERROR;
         } break;
         case GET_BUILT_IN_DISPLAY: {
+            ATRACE_NAME("GET_BUILT_IN_DISPLAY");
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             int32_t id = data.readInt32();
             sp<IBinder> display(getBuiltInDisplay(id));
@@ -315,16 +326,19 @@
             return NO_ERROR;
         } break;
         case BLANK: {
+            ATRACE_NAME("BLANK");
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             sp<IBinder> display = data.readStrongBinder();
             blank(display);
         } break;
         case UNBLANK: {
+            ATRACE_NAME("UNBLANK");
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             sp<IBinder> display = data.readStrongBinder();
             unblank(display);
         } break;
         case GET_DISPLAY_INFO: {
+            ATRACE_NAME("GET_DISPLAY_INFO");
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             DisplayInfo info;
             sp<IBinder> display = data.readStrongBinder();
Index: frameworks/native/libs/gui/SurfaceTexture.cpp
===================================================================
--- frameworks/native/libs/gui/SurfaceTexture.cpp	(revision 1831)
+++ frameworks/native/libs/gui/SurfaceTexture.cpp	(working copy)
@@ -196,7 +196,7 @@
 }
 
 status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool skipSync) {
-    ATRACE_CALL();
+    ATRACE_NAME("ST-updateTexImage");
     ST_LOGV("updateTexImage");
     Mutex::Autolock lock(mMutex);
 
@@ -334,7 +334,7 @@
 }
 
 status_t SurfaceTexture::detachFromContext() {
-    ATRACE_CALL();
+    ATRACE_NAME("ST-detachFromContext");
     ST_LOGV("detachFromContext");
     Mutex::Autolock lock(mMutex);
 
@@ -391,7 +391,7 @@
 }
 
 status_t SurfaceTexture::attachToContext(GLuint tex) {
-    ATRACE_CALL();
+    ATRACE_NAME("ST-attachToContext");
     ST_LOGV("attachToContext");
     Mutex::Autolock lock(mMutex);
 
@@ -679,6 +679,7 @@
 
 EGLImageKHR SurfaceTexture::createImage(EGLDisplay dpy,
         const sp<GraphicBuffer>& graphicBuffer) {
+    ATRACE_NAME("ST-createImage");
     EGLClientBuffer cbuf = (EGLClientBuffer)graphicBuffer->getNativeBuffer();
     EGLint attrs[] = {
         EGL_IMAGE_PRESERVED_KHR,    EGL_TRUE,
Index: frameworks/native/libs/gui/BufferQueue.cpp
===================================================================
--- frameworks/native/libs/gui/BufferQueue.cpp	(revision 1831)
+++ frameworks/native/libs/gui/BufferQueue.cpp	(working copy)
@@ -31,6 +31,7 @@
 #include <utils/Log.h>
 #include <gui/SurfaceTexture.h>
 #include <utils/Trace.h>
+#include <cutils/debugger.h>
 
 // Macros for including the BufferQueue name in log messages
 #define ST_LOGV(x, ...) ALOGV("[%s] "x, mConsumerName.string(), ##__VA_ARGS__)
@@ -197,7 +198,7 @@
 
 int BufferQueue::query(int what, int* outValue)
 {
-    ATRACE_CALL();
+    ATRACE_NAME("BQ-query");
     Mutex::Autolock lock(mMutex);
 
     if (mAbandoned) {
@@ -230,7 +231,7 @@
 }
 
 status_t BufferQueue::requestBuffer(int slot, sp<GraphicBuffer>* buf) {
-    ATRACE_CALL();
+    ATRACE_NAME("BQ-requestBuffer");
     ST_LOGV("requestBuffer: slot=%d", slot);
     Mutex::Autolock lock(mMutex);
     if (mAbandoned) {
@@ -257,8 +258,13 @@
 
 status_t BufferQueue::dequeueBuffer(int *outBuf, sp<Fence>& outFence,
         uint32_t w, uint32_t h, uint32_t format, uint32_t usage) {
-    ATRACE_CALL();
+    ATRACE_NAME("BQ-dequeueBuffer");
     ST_LOGV("dequeueBuffer: w=%d h=%d fmt=%#x usage=%#x", w, h, format, usage);
+    {
+    char __buf[100];
+    snprintf(__buf, 100, "w=%d h=%d fmt=%#x usage=%#x", w, h, format, usage);
+    ATRACE_NAME(__buf);
+    }
 
     if ((w && !h) || (!w && h)) {
         ST_LOGE("dequeueBuffer: invalid size: w=%u, h=%u", w, h);
@@ -479,7 +485,7 @@
 
 status_t BufferQueue::queueBuffer(int buf,
         const QueueBufferInput& input, QueueBufferOutput* output) {
-    ATRACE_CALL();
+    ATRACE_NAME("BQ-queueBuffer");
     ATRACE_BUFFER_INDEX(buf);
 
     Rect crop;
@@ -580,7 +586,8 @@
         output->inflate(mDefaultWidth, mDefaultHeight, mTransformHint,
                 mQueue.size());
 
-        ATRACE_INT(mConsumerName.string(), mQueue.size());
+        //ATRACE_INT(mConsumerName.string(), mQueue.size());
+        ATRACE_BUFFER_INDEX(mQueue.size());
     } // scope for the lock
 
     // call back without lock held
@@ -591,7 +598,7 @@
 }
 
 void BufferQueue::cancelBuffer(int buf, sp<Fence> fence) {
-    ATRACE_CALL();
+    ATRACE_NAME("BQ-cancelBuffer");
     ST_LOGV("cancelBuffer: slot=%d", buf);
     Mutex::Autolock lock(mMutex);
 
@@ -617,7 +624,7 @@
 }
 
 status_t BufferQueue::connect(int api, QueueBufferOutput* output) {
-    ATRACE_CALL();
+    ATRACE_NAME("BQ-connect");
     ST_LOGV("connect: api=%d", api);
     Mutex::Autolock lock(mMutex);
 
@@ -658,7 +665,7 @@
 }
 
 status_t BufferQueue::disconnect(int api) {
-    ATRACE_CALL();
+    ATRACE_NAME("BQ-disconnect");
     ST_LOGV("disconnect: api=%d", api);
 
     int err = NO_ERROR;
@@ -801,7 +808,7 @@
 }
 
 status_t BufferQueue::acquireBuffer(BufferItem *buffer) {
-    ATRACE_CALL();
+    ATRACE_NAME("BQ-acquireBuffer");
     Mutex::Autolock _l(mMutex);
 
     // Check that the consumer doesn't currently have the maximum number of
@@ -860,7 +867,7 @@
 
 status_t BufferQueue::releaseBuffer(int buf, EGLDisplay display,
         EGLSyncKHR eglFence, const sp<Fence>& fence) {
-    ATRACE_CALL();
+    ATRACE_NAME("BQ-releaseBuffer");
     ATRACE_BUFFER_INDEX(buf);
 
     Mutex::Autolock _l(mMutex);
Index: frameworks/native/libs/gui/ISurfaceTexture.cpp
===================================================================
--- frameworks/native/libs/gui/ISurfaceTexture.cpp	(revision 1831)
+++ frameworks/native/libs/gui/ISurfaceTexture.cpp	(working copy)
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+#define ATRACE_TAG ATRACE_TAG_GRAPHICS
 
 #include <stdint.h>
 #include <sys/types.h>
@@ -26,6 +27,7 @@
 #include <binder/IInterface.h>
 
 #include <gui/ISurfaceTexture.h>
+#include <utils/Trace.h>
 
 namespace android {
 // ----------------------------------------------------------------------------
@@ -52,6 +54,7 @@
     }
 
     virtual status_t requestBuffer(int bufferIdx, sp<GraphicBuffer>* buf) {
+        ATRACE_NAME("Bp->requestBuffer");
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceTexture::getInterfaceDescriptor());
         data.writeInt32(bufferIdx);
@@ -70,6 +73,7 @@
 
     virtual status_t setBufferCount(int bufferCount)
     {
+        ATRACE_NAME("Bp->setBufferCount");
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceTexture::getInterfaceDescriptor());
         data.writeInt32(bufferCount);
@@ -83,6 +87,7 @@
 
     virtual status_t dequeueBuffer(int *buf, sp<Fence>& fence,
             uint32_t w, uint32_t h, uint32_t format, uint32_t usage) {
+        ATRACE_NAME("Bp->dequeueBuffer");
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceTexture::getInterfaceDescriptor());
         data.writeInt32(w);
@@ -106,6 +111,7 @@
 
     virtual status_t queueBuffer(int buf,
             const QueueBufferInput& input, QueueBufferOutput* output) {
+        ATRACE_NAME("Bp->queueBuffer");
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceTexture::getInterfaceDescriptor());
         data.writeInt32(buf);
@@ -120,6 +126,7 @@
     }
 
     virtual void cancelBuffer(int buf, sp<Fence> fence) {
+        ATRACE_NAME("Bp->cancelBuffer");
         Parcel data, reply;
         bool hasFence = fence.get() && fence->isValid();
         data.writeInterfaceToken(ISurfaceTexture::getInterfaceDescriptor());
@@ -132,6 +139,7 @@
     }
 
     virtual int query(int what, int* value) {
+        ATRACE_NAME("Bp->query");
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceTexture::getInterfaceDescriptor());
         data.writeInt32(what);
@@ -145,6 +153,7 @@
     }
 
     virtual status_t setSynchronousMode(bool enabled) {
+        ATRACE_NAME("Bp->setSynchronousMode");
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceTexture::getInterfaceDescriptor());
         data.writeInt32(enabled);
@@ -157,6 +166,7 @@
     }
 
     virtual status_t connect(int api, QueueBufferOutput* output) {
+        ATRACE_NAME("Bp->connect");
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceTexture::getInterfaceDescriptor());
         data.writeInt32(api);
@@ -170,6 +180,7 @@
     }
 
     virtual status_t disconnect(int api) {
+        ATRACE_NAME("Bp->disconnect");
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceTexture::getInterfaceDescriptor());
         data.writeInt32(api);
@@ -191,6 +202,7 @@
 {
     switch(code) {
         case REQUEST_BUFFER: {
+            ATRACE_NAME("ST-REQUEST_BUFFER");
             CHECK_INTERFACE(ISurfaceTexture, data, reply);
             int bufferIdx   = data.readInt32();
             sp<GraphicBuffer> buffer;
@@ -203,6 +215,7 @@
             return NO_ERROR;
         } break;
         case SET_BUFFER_COUNT: {
+            ATRACE_NAME("ST-SET_BUFFER_COUNT");
             CHECK_INTERFACE(ISurfaceTexture, data, reply);
             int bufferCount = data.readInt32();
             int result = setBufferCount(bufferCount);
@@ -210,6 +223,7 @@
             return NO_ERROR;
         } break;
         case DEQUEUE_BUFFER: {
+            ATRACE_NAME("ST-DEQUEUE_BUFFER");
             CHECK_INTERFACE(ISurfaceTexture, data, reply);
             uint32_t w      = data.readInt32();
             uint32_t h      = data.readInt32();
@@ -228,6 +242,7 @@
             return NO_ERROR;
         } break;
         case QUEUE_BUFFER: {
+            ATRACE_NAME("ST-QUEUE_BUFFER");
             CHECK_INTERFACE(ISurfaceTexture, data, reply);
             int buf = data.readInt32();
             QueueBufferInput input(data);
@@ -239,6 +254,7 @@
             return NO_ERROR;
         } break;
         case CANCEL_BUFFER: {
+            ATRACE_NAME("ST-CANCEL_BUFFER");
             CHECK_INTERFACE(ISurfaceTexture, data, reply);
             int buf = data.readInt32();
             sp<Fence> fence;
@@ -251,6 +267,7 @@
             return NO_ERROR;
         } break;
         case QUERY: {
+            ATRACE_NAME("ST-QUERY");
             CHECK_INTERFACE(ISurfaceTexture, data, reply);
             int value;
             int what = data.readInt32();
@@ -260,6 +277,7 @@
             return NO_ERROR;
         } break;
         case SET_SYNCHRONOUS_MODE: {
+            ATRACE_NAME("ST-SET_SYNCHRONOUS_MODE");
             CHECK_INTERFACE(ISurfaceTexture, data, reply);
             bool enabled = data.readInt32();
             status_t res = setSynchronousMode(enabled);
@@ -267,6 +285,7 @@
             return NO_ERROR;
         } break;
         case CONNECT: {
+            ATRACE_NAME("ST-CONNECT");
             CHECK_INTERFACE(ISurfaceTexture, data, reply);
             int api = data.readInt32();
             QueueBufferOutput* const output =
@@ -277,6 +296,7 @@
             return NO_ERROR;
         } break;
         case DISCONNECT: {
+            ATRACE_NAME("ST-DISCONNECT");
             CHECK_INTERFACE(ISurfaceTexture, data, reply);
             int api = data.readInt32();
             status_t res = disconnect(api);
Index: frameworks/native/libs/gui/SurfaceTextureClient.cpp
===================================================================
--- frameworks/native/libs/gui/SurfaceTextureClient.cpp	(revision 1831)
+++ frameworks/native/libs/gui/SurfaceTextureClient.cpp	(working copy)
@@ -37,6 +37,7 @@
 SurfaceTextureClient::SurfaceTextureClient(
         const sp<ISurfaceTexture>& surfaceTexture)
 {
+    ATRACE_NAME("STC-SurfaceTexutreClient with IST");
     SurfaceTextureClient::init();
     SurfaceTextureClient::setISurfaceTexture(surfaceTexture);
 }
@@ -45,11 +46,13 @@
 SurfaceTextureClient::SurfaceTextureClient(const
          sp<SurfaceTexture>& surfaceTexture)
 {
+    ATRACE_NAME("STC-SurfaceTexutreClient with ST");
     SurfaceTextureClient::init();
     SurfaceTextureClient::setISurfaceTexture(surfaceTexture->getBufferQueue());
 }
 
 SurfaceTextureClient::SurfaceTextureClient() {
+    ATRACE_NAME("STC-SurfaceTexutreClient");
     SurfaceTextureClient::init();
 }
 
@@ -176,7 +179,7 @@
 }
 
 int SurfaceTextureClient::setSwapInterval(int interval) {
-    ATRACE_CALL();
+    ATRACE_NAME("STC-setSwapInterval");
     // EGL specification states:
     //  interval is silently clamped to minimum and maximum implementation
     //  dependent values before being stored.
@@ -195,7 +198,7 @@
 
 int SurfaceTextureClient::dequeueBuffer(android_native_buffer_t** buffer,
         int* fenceFd) {
-    ATRACE_CALL();
+    ATRACE_NAME("STC-dequeueBuffer");
     ALOGV("SurfaceTextureClient::dequeueBuffer");
     Mutex::Autolock lock(mMutex);
     int buf = -1;
@@ -242,7 +245,7 @@
 
 int SurfaceTextureClient::cancelBuffer(android_native_buffer_t* buffer,
         int fenceFd) {
-    ATRACE_CALL();
+    ATRACE_NAME("STC-cancelBuffer");
     ALOGV("SurfaceTextureClient::cancelBuffer");
     Mutex::Autolock lock(mMutex);
     int i = getSlotFromBufferLocked(buffer);
@@ -274,7 +277,7 @@
 }
 
 int SurfaceTextureClient::queueBuffer(android_native_buffer_t* buffer, int fenceFd) {
-    ATRACE_CALL();
+    ATRACE_NAME("STC-queueBuffer");
     ALOGV("SurfaceTextureClient::queueBuffer");
     Mutex::Autolock lock(mMutex);
     int64_t timestamp;
@@ -313,7 +316,7 @@
 }
 
 int SurfaceTextureClient::query(int what, int* value) const {
-    ATRACE_CALL();
+    ATRACE_NAME("STC-query");
     ALOGV("SurfaceTextureClient::query");
     { // scope for the lock
         Mutex::Autolock lock(mMutex);
@@ -365,6 +368,10 @@
 
 int SurfaceTextureClient::perform(int operation, va_list args)
 {
+    char __buf[20];
+    snprintf(__buf, 20, "STC-perform OPE: %d", operation);
+    ATRACE_NAME(__buf);
+    
     int res = NO_ERROR;
     switch (operation) {
     case NATIVE_WINDOW_CONNECT:
@@ -423,31 +430,37 @@
 }
 
 int SurfaceTextureClient::dispatchConnect(va_list args) {
+    ATRACE_CALL();
     int api = va_arg(args, int);
     return connect(api);
 }
 
 int SurfaceTextureClient::dispatchDisconnect(va_list args) {
+    ATRACE_CALL();
     int api = va_arg(args, int);
     return disconnect(api);
 }
 
 int SurfaceTextureClient::dispatchSetUsage(va_list args) {
+    ATRACE_CALL();
     int usage = va_arg(args, int);
     return setUsage(usage);
 }
 
 int SurfaceTextureClient::dispatchSetCrop(va_list args) {
+    ATRACE_CALL();
     android_native_rect_t const* rect = va_arg(args, android_native_rect_t*);
     return setCrop(reinterpret_cast<Rect const*>(rect));
 }
 
 int SurfaceTextureClient::dispatchSetBufferCount(va_list args) {
+    ATRACE_CALL();
     size_t bufferCount = va_arg(args, size_t);
     return setBufferCount(bufferCount);
 }
 
 int SurfaceTextureClient::dispatchSetBuffersGeometry(va_list args) {
+    ATRACE_CALL();
     int w = va_arg(args, int);
     int h = va_arg(args, int);
     int f = va_arg(args, int);
@@ -459,50 +472,58 @@
 }
 
 int SurfaceTextureClient::dispatchSetBuffersDimensions(va_list args) {
+    ATRACE_CALL();
     int w = va_arg(args, int);
     int h = va_arg(args, int);
     return setBuffersDimensions(w, h);
 }
 
 int SurfaceTextureClient::dispatchSetBuffersUserDimensions(va_list args) {
+    ATRACE_CALL();
     int w = va_arg(args, int);
     int h = va_arg(args, int);
     return setBuffersUserDimensions(w, h);
 }
 
 int SurfaceTextureClient::dispatchSetBuffersFormat(va_list args) {
+    ATRACE_CALL();
     int f = va_arg(args, int);
     return setBuffersFormat(f);
 }
 
 int SurfaceTextureClient::dispatchSetScalingMode(va_list args) {
+    ATRACE_CALL();
     int m = va_arg(args, int);
     return setScalingMode(m);
 }
 
 int SurfaceTextureClient::dispatchSetBuffersTransform(va_list args) {
+    ATRACE_CALL();
     int transform = va_arg(args, int);
     return setBuffersTransform(transform);
 }
 
 int SurfaceTextureClient::dispatchSetBuffersTimestamp(va_list args) {
+    ATRACE_CALL();
     int64_t timestamp = va_arg(args, int64_t);
     return setBuffersTimestamp(timestamp);
 }
 
 int SurfaceTextureClient::dispatchLock(va_list args) {
+    ATRACE_CALL();
     ANativeWindow_Buffer* outBuffer = va_arg(args, ANativeWindow_Buffer*);
     ARect* inOutDirtyBounds = va_arg(args, ARect*);
     return lock(outBuffer, inOutDirtyBounds);
 }
 
 int SurfaceTextureClient::dispatchUnlockAndPost(va_list args) {
+    ATRACE_CALL();
     return unlockAndPost();
 }
 
 
 int SurfaceTextureClient::connect(int api) {
-    ATRACE_CALL();
+    ATRACE_NAME("STC-connect");
     ALOGV("SurfaceTextureClient::connect");
     Mutex::Autolock lock(mMutex);
     ISurfaceTexture::QueueBufferOutput output;
@@ -520,7 +541,7 @@
 }
 
 int SurfaceTextureClient::disconnect(int api) {
-    ATRACE_CALL();
+    ATRACE_NAME("STC-disconnect");
     ALOGV("SurfaceTextureClient::disconnect");
     Mutex::Autolock lock(mMutex);
     freeAllBuffers();
@@ -732,6 +753,7 @@
 status_t SurfaceTextureClient::lock(
         ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)
 {
+    ATRACE_NAME("STC-lock");
     if (mLockedBuffer != 0) {
         ALOGE("Surface::lock failed, already locked");
         return INVALID_OPERATION;
@@ -842,6 +864,7 @@
 
 status_t SurfaceTextureClient::unlockAndPost()
 {
+    ATRACE_NAME("STC-unlockAndPost");
     if (mLockedBuffer == 0) {
         ALOGE("Surface::unlockAndPost failed, no locked buffer");
         return INVALID_OPERATION;
